# task 2
# время между последовательными звонками в колл-центр за день
calls = c(1, 1, 7, 16, 8, 8, 11, 7, 5, 45, 13, 0, 36, 15, 4, 15, 7, 39, 6, 91, 28, 7, 0, 2,
9, 2, 6, 1, 4, 83, 2, 3, 5, 34, 1, 1, 2, 0, 11, 79, 2, 2, 4, 1, 3, 0, 2, 2, 17, 55, 8,
9, 20, 23, 16, 3, 5, 5, 4, 84, 1, 20, 1, 1, 20, 0, 19, 17, 5, 66, 0, 2, 5, 1, 26,
14, 1, 0, 9, 88, 4, 11, 4, 2, 1, 32, 21, 2, 15, 76, 44, 8, 16, 12, 1, 9)

# проверим, что сумма меньше суток
sum(calls)/60 < 24 # TRUE

#  проверим выборку на соответствие экспоненциальному распределению

# оценка параметра lambda по методу максимального правдоподобия для распределения 
# из экспоненциального семейства (совпадает с оценкой методом моментов)
m = length(calls) / sum(calls)

# возьмем интервалы равномерно, по 5 квантилям, тогда  теоретическое количество 
# элементов, попадающих в каждый из интервалов, будет равно round(96/5) минимум 19,
# что больше 5 (так как 96 не делится нацело на 5, и в остатке получаем 1, 
# то в одном из интервалов будет 20, в остальных по 19)
p = seq(0, 5, 1)/5
q = qexp(p = p, rate = m)

# теоретическое распределение для 96 значений для графика (применим бутстрэп)
r = rep(0, 96)
for (i in 1:10000){
  r = r + sort(rexp(96, rate = m))
} 
r = r / 10000

# проверяем, сколько значений попадет в каждый интервал для теоретического
# и наблюдаемого распределений (график)

plot(sort(r), col='red', lwd = 2, type='o', pch=20,
     main="Calls distribution for theoretical and observed samples", 
     xlab="index of sorted values", ylab="value", ylim = c(0, 100))
points(sort(calls), col='blue', lwd = 2, pch=20)
lines(sort(calls), col='blue', lwd = 2)
legend(x = 'topleft', col = c('red', 'blue', 'grey'), lwd = 2, lty = c(1, 1, 2),
       legend = c('theoretical', 'observed', 'quantiles'))
for (i in 2:5){
  lines(rep(q[i], 96), lty=2, col='grey')
}

# сформируем матрицу значений (таблицу сопряжённости)

A = matrix(data = NA, nrow = 5, ncol = 2, 
           dimnames = list(1:5, c('observed', 'theoretical')))

thres = pexp(q, rate = m) * 96

for (i in 1:5){
  A[i, 2] = thres[i + 1] - thres[i]
  A[i, 1] = sum(q[i] <= calls & calls < q[i + 1])
}

# считаем статистику хи квадрат
ch = 0
for (i in 1:5){
  ch = ch + (A[i, 1] - A[i, 2]) ^ 2 / A[i, 2]
}
ch # 14.9375

# сравниваем статистику с критерием хи-квадрат на уровне значимости alpha = 0.05.
# количество степеней свободы берем равным 3, т.к. значений для сравнения 5, 
# количество оцененных параметров - 1, и по формуле получаем 5-1-1 = 3.
ch < qchisq(0.95, df=3) # FALSE

# таким образом, на уровне значимости alpha = 0.05 мы отвергаем нулевую гипотезу
# о том, что количество поступивших звонков можно смоделировать процессом Пуассона,
# если взять за границы интервалов квантили равномерно.

# попробуем руками установить границы
# сформируем матрицу значений (таблицу сопряжённости)

q_man = c(0, 7, 11, 16, 28, Inf)

# пересчитаем теоретические значения для этих порогов

A_man = matrix(data = NA, nrow = 5, ncol = 2, 
               dimnames = list(1:5, c('observed', 'theoretical')))
thres_man = pexp(q_man, rate = m) * 96

for (i in 1:5){
  A_man[i, 1] = sum(q_man[i] <= calls & calls < q_man[i + 1])
  A_man[i, 2] = thres_man[i + 1] - thres_man[i]
}

# считаем статистику хи квадрат
ch_man = 0
for (i in 1:5){
  ch_man = ch_man + (A_man[i, 1] - A_man[i, 2]) ^ 2 / A_man[i, 2]
}

ch_man # 7.748215
ch_man < qchisq(0.95, df=3) # TRUE

# таким образом, на уровне значимости alpha = 0.05 мы не отвергаем нулевую гипотезу
# о том, что количество поступивших звонков можно смоделировать процессом Пуассона,
# при ручном подборе интервалов  таким образом, чтобы в каждом теоретическом интервале 
# было не менее 5 значений.

